{"ast":null,"code":"import _toConsumableArray from \"/Users/mithilproof/Oleic/react-dep/metal-baby/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/Users/mithilproof/Oleic/react-dep/metal-baby/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _slicedToArray from \"/Users/mithilproof/Oleic/react-dep/metal-baby/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"/Users/mithilproof/Oleic/react-dep/metal-baby/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _effectMap;\n\nimport * as ACTIONS from \"./constants/actionTypes\";\nimport { EAT, BATHE, PLAY, IDLE } from \"./constants/taskTypes\";\nimport { initialNeeds, initialSpeed, ticksPerSpeedup, speedUpPercent, maxSpeed, needsDecay, eatEffect, batheEffect, playEffect, idleEffect, maxNeeds, effectVariance } from \"./gameConfig\";\nimport { clamp } from \"./utils\";\nexport var initialState = {\n  time: 1,\n  // to allow for past events to be seen\n  tasks: [IDLE, IDLE],\n  needs: initialNeeds,\n  speed: initialSpeed,\n  playing: false,\n  gameOver: false,\n  gameNumber: 0\n};\nvar effectMap = (_effectMap = {}, _defineProperty(_effectMap, EAT, eatEffect), _defineProperty(_effectMap, BATHE, batheEffect), _defineProperty(_effectMap, PLAY, playEffect), _defineProperty(_effectMap, IDLE, idleEffect), _effectMap);\n\nvar checkGameOver = function checkGameOver(needs) {\n  return Object.entries(needs).some(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        need = _ref2[0],\n        value = _ref2[1];\n\n    return value <= 0;\n  });\n};\n\nvar game = function game() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  // console.log(action, state);\n  // TODO: clean this up\n  switch (action.type) {\n    case ACTIONS.TICK:\n      {\n        // check for game over\n        if (checkGameOver(state.needs)) {\n          return _objectSpread({}, state, {\n            playing: false,\n            gameOver: true\n          });\n        }\n\n        var newTime = state.time + 1; // speed up by % if interval is appropriate\n\n        var newSpeed = state.speed;\n\n        if (state.time % ticksPerSpeedup === 0) {\n          newSpeed = Math.max(state.speed * (1 - speedUpPercent / 100), maxSpeed);\n        }\n\n        var currentTask = state.tasks[newTime];\n\n        var newTasks = _toConsumableArray(state.tasks); // if no task, add IDLE block\n\n\n        if (currentTask === undefined) {\n          currentTask = IDLE;\n          newTasks[newTime] = currentTask;\n        }\n\n        var taskEffect = effectMap[currentTask]; // decay each need, apply the current action from the queue\n\n        var newNeeds = Object.entries(state.needs).reduce(function (acc, _ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              need = _ref4[0],\n              value = _ref4[1];\n\n          var effect = (1 - Math.random() * effectVariance) * taskEffect[need];\n          acc[need] = clamp(value - needsDecay[need] + effect, 0, maxNeeds[need]);\n          return acc;\n        }, {});\n        return _objectSpread({}, state, {\n          needs: newNeeds,\n          tasks: newTasks,\n          time: newTime,\n          speed: newSpeed\n        });\n      }\n\n    case ACTIONS.TASK_ADDED:\n      {\n        var task = action.task;\n        return _objectSpread({}, state, {\n          tasks: [].concat(_toConsumableArray(state.tasks), [task])\n        });\n      }\n\n    case ACTIONS.GAME_STARTED:\n      {\n        return _objectSpread({}, initialState, {\n          playing: true,\n          gameNumber: state.gameNumber + 1\n        });\n      }\n\n    default:\n      return state;\n  }\n};\n\nexport default game;","map":{"version":3,"sources":["/Users/mithilproof/Oleic/react-dep/metal-baby/src/gameReducer.js"],"names":["ACTIONS","EAT","BATHE","PLAY","IDLE","initialNeeds","initialSpeed","ticksPerSpeedup","speedUpPercent","maxSpeed","needsDecay","eatEffect","batheEffect","playEffect","idleEffect","maxNeeds","effectVariance","clamp","initialState","time","tasks","needs","speed","playing","gameOver","gameNumber","effectMap","checkGameOver","Object","entries","some","need","value","game","state","action","type","TICK","newTime","newSpeed","Math","max","currentTask","newTasks","undefined","taskEffect","newNeeds","reduce","acc","effect","random","TASK_ADDED","task","GAME_STARTED"],"mappings":";;;;;;;AAAA,OAAO,KAAKA,OAAZ,MAAyB,yBAAzB;AACA,SAASC,GAAT,EAAcC,KAAd,EAAqBC,IAArB,EAA2BC,IAA3B,QAAuC,uBAAvC;AACA,SACEC,YADF,EAEEC,YAFF,EAGEC,eAHF,EAIEC,cAJF,EAKEC,QALF,EAMEC,UANF,EAOEC,SAPF,EAQEC,WARF,EASEC,UATF,EAUEC,UAVF,EAWEC,QAXF,EAYEC,cAZF,QAaO,cAbP;AAcA,SAASC,KAAT,QAAsB,SAAtB;AAEA,OAAO,IAAMC,YAAY,GAAG;AAC1BC,EAAAA,IAAI,EAAE,CADoB;AACjB;AACTC,EAAAA,KAAK,EAAE,CAAChB,IAAD,EAAOA,IAAP,CAFmB;AAG1BiB,EAAAA,KAAK,EAAEhB,YAHmB;AAI1BiB,EAAAA,KAAK,EAAEhB,YAJmB;AAK1BiB,EAAAA,OAAO,EAAE,KALiB;AAM1BC,EAAAA,QAAQ,EAAE,KANgB;AAO1BC,EAAAA,UAAU,EAAE;AAPc,CAArB;AAUP,IAAMC,SAAS,iDACZzB,GADY,EACNU,SADM,+BAEZT,KAFY,EAEJU,WAFI,+BAGZT,IAHY,EAGLU,UAHK,+BAIZT,IAJY,EAILU,UAJK,cAAf;;AAOA,IAAMa,aAAa,GAAG,SAAhBA,aAAgB,CAAAN,KAAK;AAAA,SACzBO,MAAM,CAACC,OAAP,CAAeR,KAAf,EAAsBS,IAAtB,CAA2B;AAAA;AAAA,QAAEC,IAAF;AAAA,QAAQC,KAAR;;AAAA,WAAmBA,KAAK,IAAI,CAA5B;AAAA,GAA3B,CADyB;AAAA,CAA3B;;AAGA,IAAMC,IAAI,GAAG,SAAPA,IAAO,GAAkC;AAAA,MAAjCC,KAAiC,uEAAzBhB,YAAyB;AAAA,MAAXiB,MAAW;;AAC7C;AAEA;AACA,UAAQA,MAAM,CAACC,IAAf;AACE,SAAKpC,OAAO,CAACqC,IAAb;AAAmB;AACjB;AACA,YAAIV,aAAa,CAACO,KAAK,CAACb,KAAP,CAAjB,EAAgC;AAC9B,mCACKa,KADL;AAEEX,YAAAA,OAAO,EAAE,KAFX;AAGEC,YAAAA,QAAQ,EAAE;AAHZ;AAKD;;AAED,YAAMc,OAAO,GAAGJ,KAAK,CAACf,IAAN,GAAa,CAA7B,CAViB,CAYjB;;AACA,YAAIoB,QAAQ,GAAGL,KAAK,CAACZ,KAArB;;AACA,YAAIY,KAAK,CAACf,IAAN,GAAaZ,eAAb,KAAiC,CAArC,EAAwC;AACtCgC,UAAAA,QAAQ,GAAGC,IAAI,CAACC,GAAL,CAASP,KAAK,CAACZ,KAAN,IAAe,IAAId,cAAc,GAAG,GAApC,CAAT,EAAmDC,QAAnD,CAAX;AACD;;AAED,YAAIiC,WAAW,GAAGR,KAAK,CAACd,KAAN,CAAYkB,OAAZ,CAAlB;;AAEA,YAAIK,QAAQ,sBAAOT,KAAK,CAACd,KAAb,CAAZ,CApBiB,CAqBjB;;;AACA,YAAIsB,WAAW,KAAKE,SAApB,EAA+B;AAC7BF,UAAAA,WAAW,GAAGtC,IAAd;AACAuC,UAAAA,QAAQ,CAACL,OAAD,CAAR,GAAoBI,WAApB;AACD;;AAED,YAAMG,UAAU,GAAGnB,SAAS,CAACgB,WAAD,CAA5B,CA3BiB,CA4BjB;;AACA,YAAMI,QAAQ,GAAGlB,MAAM,CAACC,OAAP,CAAeK,KAAK,CAACb,KAArB,EAA4B0B,MAA5B,CACf,UAACC,GAAD,SAAwB;AAAA;AAAA,cAAjBjB,IAAiB;AAAA,cAAXC,KAAW;;AACtB,cAAMiB,MAAM,GACV,CAAC,IAAIT,IAAI,CAACU,MAAL,KAAgBlC,cAArB,IAAuC6B,UAAU,CAACd,IAAD,CADnD;AAEAiB,UAAAA,GAAG,CAACjB,IAAD,CAAH,GAAYd,KAAK,CACfe,KAAK,GAAGtB,UAAU,CAACqB,IAAD,CAAlB,GAA2BkB,MADZ,EAEf,CAFe,EAGflC,QAAQ,CAACgB,IAAD,CAHO,CAAjB;AAKA,iBAAOiB,GAAP;AACD,SAVc,EAWf,EAXe,CAAjB;AAaA,iCACKd,KADL;AAEEb,UAAAA,KAAK,EAAEyB,QAFT;AAGE1B,UAAAA,KAAK,EAAEuB,QAHT;AAIExB,UAAAA,IAAI,EAAEmB,OAJR;AAKEhB,UAAAA,KAAK,EAAEiB;AALT;AAOD;;AAED,SAAKvC,OAAO,CAACmD,UAAb;AAAyB;AAAA,YACfC,IADe,GACNjB,MADM,CACfiB,IADe;AAEvB,iCACKlB,KADL;AAEEd,UAAAA,KAAK,+BAAMc,KAAK,CAACd,KAAZ,IAAmBgC,IAAnB;AAFP;AAID;;AAED,SAAKpD,OAAO,CAACqD,YAAb;AAA2B;AACzB,iCACKnC,YADL;AAEEK,UAAAA,OAAO,EAAE,IAFX;AAGEE,UAAAA,UAAU,EAAES,KAAK,CAACT,UAAN,GAAmB;AAHjC;AAKD;;AAED;AACE,aAAOS,KAAP;AArEJ;AAuED,CA3ED;;AA6EA,eAAeD,IAAf","sourcesContent":["import * as ACTIONS from \"./constants/actionTypes\";\nimport { EAT, BATHE, PLAY, IDLE } from \"./constants/taskTypes\";\nimport {\n  initialNeeds,\n  initialSpeed,\n  ticksPerSpeedup,\n  speedUpPercent,\n  maxSpeed,\n  needsDecay,\n  eatEffect,\n  batheEffect,\n  playEffect,\n  idleEffect,\n  maxNeeds,\n  effectVariance\n} from \"./gameConfig\";\nimport { clamp } from \"./utils\";\n\nexport const initialState = {\n  time: 1, // to allow for past events to be seen\n  tasks: [IDLE, IDLE],\n  needs: initialNeeds,\n  speed: initialSpeed,\n  playing: false,\n  gameOver: false,\n  gameNumber: 0\n};\n\nconst effectMap = {\n  [EAT]: eatEffect,\n  [BATHE]: batheEffect,\n  [PLAY]: playEffect,\n  [IDLE]: idleEffect\n};\n\nconst checkGameOver = needs =>\n  Object.entries(needs).some(([need, value]) => value <= 0);\n\nconst game = (state = initialState, action) => {\n  // console.log(action, state);\n\n  // TODO: clean this up\n  switch (action.type) {\n    case ACTIONS.TICK: {\n      // check for game over\n      if (checkGameOver(state.needs)) {\n        return {\n          ...state,\n          playing: false,\n          gameOver: true\n        };\n      }\n\n      const newTime = state.time + 1;\n\n      // speed up by % if interval is appropriate\n      let newSpeed = state.speed;\n      if (state.time % ticksPerSpeedup === 0) {\n        newSpeed = Math.max(state.speed * (1 - speedUpPercent / 100), maxSpeed);\n      }\n\n      let currentTask = state.tasks[newTime];\n\n      let newTasks = [...state.tasks];\n      // if no task, add IDLE block\n      if (currentTask === undefined) {\n        currentTask = IDLE;\n        newTasks[newTime] = currentTask;\n      }\n\n      const taskEffect = effectMap[currentTask];\n      // decay each need, apply the current action from the queue\n      const newNeeds = Object.entries(state.needs).reduce(\n        (acc, [need, value]) => {\n          const effect =\n            (1 - Math.random() * effectVariance) * taskEffect[need];\n          acc[need] = clamp(\n            value - needsDecay[need] + effect,\n            0,\n            maxNeeds[need]\n          );\n          return acc;\n        },\n        {}\n      );\n      return {\n        ...state,\n        needs: newNeeds,\n        tasks: newTasks,\n        time: newTime,\n        speed: newSpeed\n      };\n    }\n\n    case ACTIONS.TASK_ADDED: {\n      const { task } = action;\n      return {\n        ...state,\n        tasks: [...state.tasks, task]\n      };\n    }\n\n    case ACTIONS.GAME_STARTED: {\n      return {\n        ...initialState,\n        playing: true,\n        gameNumber: state.gameNumber + 1\n      };\n    }\n\n    default:\n      return state;\n  }\n};\n\nexport default game;\n"]},"metadata":{},"sourceType":"module"}